<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Skeletal Shenanigans - Official Recreation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0505;
            overflow: hidden;
            font-family: 'Arial Black', Arial, sans-serif;
            color: #ff6b47;
            cursor: none;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }

        #gameCanvas {
            display: block;
            background: linear-gradient(180deg, #1a0808 0%, #2d1010 50%, #0f0505 100%);
            image-rendering: pixelated;
        }

        .ui-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            font-size: 16px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            color: #ff8855;
            font-family: 'Courier New', monospace;
        }

        .controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            font-size: 12px;
            color: #666;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }

        .title {
            position: absolute;
            top: 45%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 52px;
            font-weight: bold;
            color: #ff6b47;
            text-shadow: 0 0 20px #ff6b47, 3px 3px 6px rgba(0,0,0,0.8);
            z-index: 200;
            animation: pulse 2s ease-in-out infinite;
            pointer-events: none;
            letter-spacing: 3px;
        }

        .subtitle {
            position: absolute;
            top: 55%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 16px;
            color: #cc5533;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 200;
            pointer-events: none;
            font-style: italic;
        }

        .level-info {
            position: absolute;
            top: 65%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 12px;
            color: #888;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            z-index: 200;
            pointer-events: none;
            text-align: center;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.9; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.02); }
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-3px); }
            75% { transform: translateX(3px); }
        }

        .death-effect {
            animation: shake 0.4s ease-in-out;
        }

        #particles {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 50;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <canvas id="particles"></canvas>
        
        <div class="ui-overlay">
            <div>Progress: <span id="progress">0%</span></div>
            <div>Attempts: <span id="attempts">1</span></div>
            <div>Best: <span id="best">0%</span></div>
            <div>Section: <span id="section">Menu</span></div>
        </div>

        <div class="controls">
            CLICK/SPACE to jump/fly • R to restart • ESC to menu
        </div>

        <div class="title" id="title">SKELETAL SHENANIGANS</div>
        <div class="subtitle" id="subtitle">Click to steal the skeleton's jewel...</div>
        <div class="level-info" id="levelInfo">
            Medium Demon by YoReid & Airzyy<br>
            Event Level • 10 Stars
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const particleCanvas = document.getElementById('particles');
        const particleCtx = particleCanvas.getContext('2d');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        particleCanvas.width = window.innerWidth;
        particleCanvas.height = window.innerHeight;

        // Game state
        let gameState = 'menu'; // menu, playing, dead
        let gameSpeed = 5;
        let scrollOffset = 0;
        let attempts = 1;
        let bestProgress = 0;
        let currentProgress = 0;
        let levelLength = 8000;
        let currentSection = 'Forest Chase';
        let sectionProgress = 0;

        // Level sections based on actual level
        const sections = [
            { name: 'Forest Chase', start: 0, end: 2000, mode: 'cube', theme: 'forest' },
            { name: 'Cave Spider', start: 2000, end: 4000, mode: 'spider', theme: 'cave' },
            { name: 'Castle Interior', start: 4000, end: 6500, mode: 'cube', theme: 'castle' },
            { name: 'Boss Fight', start: 6500, end: 8000, mode: 'ship', theme: 'tower' }
        ];

        // Player object
        const player = {
            x: 150,
            y: canvas.height / 2,
            width: 28,
            height: 28,
            velocityY: 0,
            onGround: false,
            rotation: 0,
            mode: 'cube', // cube, ship, ball, ufo, wave, robot, spider
            gravity: 0.7,
            jumpPower: -14,
            color: '#ff6b47',
            trail: []
        };

        // Game objects
        let obstacles = [];
        let decorations = [];
        let particles = [];
        let backgroundElements = [];
        let jewel = { x: 300, y: canvas.height - 150, collected: false, glow: 0 };
        let giantSkeleton = { x: 0, y: 0, visible: false, phase: 0 };
        let boss = { x: 0, y: 0, active: false, health: 100, fireballs: [] };

        // Input handling
        let keys = {};
        let mouseDown = false;

        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            if (e.code === 'Space' && gameState === 'playing') {
                e.preventDefault();
                jump();
            }
            if (e.code === 'KeyR') {
                restart();
            }
            if (e.code === 'Escape') {
                goToMenu();
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });

        document.addEventListener('mousedown', (e) => {
            mouseDown = true;
            if (gameState === 'menu') {
                startGame();
            } else if (gameState === 'playing') {
                jump();
            } else if (gameState === 'dead') {
                restart();
            }
        });

        document.addEventListener('mouseup', () => {
            mouseDown = false;
        });

        // Generate authentic level content
        function generateLevel() {
            obstacles = [];
            decorations = [];
            backgroundElements = [];

            // Forest Chase section (0-2000)
            generateForestChase(0, 2000);
            
            // Cave Spider section (2000-4000)
            generateCaveSpider(2000, 4000);
            
            // Castle Interior section (4000-6500)
            generateCastleInterior(4000, 6500);
            
            // Boss Fight section (6500-8000)
            generateBossFight(6500, 8000);
        }

        function generateForestChase(start, end) {
            // Forest background elements
            for (let i = start; i < end; i += 150) {
                backgroundElements.push({
                    x: i + Math.random() * 100,
                    y: canvas.height - 200 - Math.random() * 150,
                    type: 'tree',
                    scale: 0.8 + Math.random() * 0.4,
                    layer: 0.3
                });
            }

            // Giant skeleton in background
            giantSkeleton = {
                x: start + 500,
                y: canvas.height - 400,
                visible: true,
                phase: 0,
                eyes: { glow: 0 }
            };

            // Basic obstacles with forest theme
            for (let i = start + 200; i < end; i += 120) {
                if (Math.random() < 0.7) {
                    obstacles.push({
                        x: i + Math.random() * 80,
                        y: canvas.height - 50,
                        width: 35,
                        height: 50,
                        type: 'tree_spike',
                        deadly: true,
                        section: 'forest'
                    });
                }

                // Floating platforms
                if (Math.random() < 0.3) {
                    obstacles.push({
                        x: i + Math.random() * 60,
                        y: canvas.height - 180 - Math.random() * 80,
                        width: 100,
                        height: 15,
                        type: 'branch_platform',
                        deadly: false,
                        section: 'forest'
                    });
                }
            }

            // Add the stolen jewel at the beginning
            jewel = {
                x: start + 300,
                y: canvas.height - 120,
                collected: false,
                glow: 0,
                floating: 0
            };
        }

        function generateCaveSpider(start, end) {
            // Cave background
            for (let i = start; i < end; i += 100) {
                backgroundElements.push({
                    x: i,
                    y: 0,
                    type: 'cave_wall',
                    width: canvas.width,
                    height: canvas.height,
                    layer: 0.1
                });
            }

            // Tight spider obstacles
            for (let i = start; i < end; i += 80) {
                // Ceiling and floor spikes
                if (Math.random() < 0.8) {
                    obstacles.push({
                        x: i + Math.random() * 40,
                        y: canvas.height - 45,
                        width: 30,
                        height: 45,
                        type: 'cave_spike_up',
                        deadly: true,
                        section: 'cave'
                    });
                }

                if (Math.random() < 0.6) {
                    obstacles.push({
                        x: i + Math.random() * 40,
                        y: 0,
                        width: 30,
                        height: 45,
                        type: 'cave_spike_down',
                        deadly: true,
                        section: 'cave'
                    });
                }

                // Narrow passages
                if (Math.random() < 0.4) {
                    obstacles.push({
                        x: i + 50,
                        y: canvas.height - 200,
                        width: 20,
                        height: 100,
                        type: 'cave_wall',
                        deadly: true,
                        section: 'cave'
                    });
                }
            }
        }

        function generateCastleInterior(start, end) {
            // Castle walls and architecture
            for (let i = start; i < end; i += 200) {
                backgroundElements.push({
                    x: i,
                    y: 0,
                    type: 'castle_wall',
                    width: 200,
                    height: canvas.height,
                    layer: 0.2
                });

                // Castle columns
                decorations.push({
                    x: i + 50,
                    y: canvas.height - 300,
                    type: 'castle_column',
                    height: 300
                });
            }

            // Castle obstacles
            for (let i = start; i < end; i += 100) {
                if (Math.random() < 0.6) {
                    obstacles.push({
                        x: i + Math.random() * 60,
                        y: canvas.height - 60,
                        width: 40,
                        height: 60,
                        type: 'castle_spike',
                        deadly: true,
                        section: 'castle'
                    });
                }

                // Moving platforms
                if (Math.random() < 0.4) {
                    obstacles.push({
                        x: i + Math.random() * 50,
                        y: canvas.height - 200 - Math.random() * 100,
                        width: 80,
                        height: 15,
                        type: 'castle_platform',
                        deadly: false,
                        section: 'castle',
                        moving: true,
                        moveSpeed: 1
                    });
                }
            }
        }

        function generateBossFight(start, end) {
            // Tower interior background
            backgroundElements.push({
                x: start,
                y: 0,
                type: 'tower_interior',
                width: end - start,
                height: canvas.height,
                layer: 0.1
            });

            // Boss setup
            boss = {
                x: start + 600,
                y: 100,
                active: false,
                health: 100,
                maxHealth: 100,
                fireballs: [],
                crystal: {
                    x: start + 650,
                    y: 150,
                    glow: 0,
                    rotation: 0
                },
                phase: 0,
                attackTimer: 0
            };

            // No regular obstacles in boss fight - just boss attacks
        }

        function jump() {
            const section = getCurrentSection();
            
            if (section.mode === 'cube' && player.onGround) {
                player.velocityY = player.jumpPower;
                player.onGround = false;
                createJumpParticles();
            } else if (section.mode === 'ship' || (section.mode === 'ship' && mouseDown)) {
                player.velocityY -= 1.5;
                createThrustParticles();
            } else if (section.mode === 'spider') {
                // Spider teleport/flip mechanics
                if (player.onGround) {
                    player.velocityY = player.jumpPower * 0.8;
                    player.onGround = false;
                }
            }
        }

        function getCurrentSection() {
            for (let section of sections) {
                if (scrollOffset >= section.start && scrollOffset < section.end) {
                    currentSection = section.name;
                    player.mode = section.mode;
                    return section;
                }
            }
            return sections[0];
        }

        function updatePlayer() {
            const section = getCurrentSection();
            
            // Update player mode and physics based on section
            if (section.mode === 'ship') {
                // Ship physics - continuous thrust control
                if (mouseDown || keys['Space']) {
                    player.velocityY -= 1.2;
                } else {
                    player.velocityY += 0.5; // Gentle fall
                }
                player.velocityY *= 0.95; // Air resistance
            } else {
                // Cube/Spider physics
                player.velocityY += player.gravity;
            }

            // Update position
            player.y += player.velocityY;

            // Ground collision
            const groundY = canvas.height - 50;
            if (player.y + player.height > groundY) {
                player.y = groundY - player.height;
                if (section.mode !== 'ship') {
                    player.velocityY = 0;
                    player.onGround = true;
                }
            } else {
                player.onGround = false;
            }

            // Ceiling collision
            if (player.y < 0) {
                player.y = 0;
                if (section.mode !== 'ship') {
                    player.velocityY = 0;
                }
            }

            // Update rotation
            if (section.mode === 'cube') {
                player.rotation = (scrollOffset * 0.02) % (Math.PI * 2);
            } else if (section.mode === 'ship') {
                player.rotation = player.velocityY * 0.05;
            }

            // Update player trail
            player.trail.unshift({ x: player.x + player.width/2, y: player.y + player.height/2 });
            if (player.trail.length > 8) player.trail.pop();

            // Check jewel collection
            if (!jewel.collected && scrollOffset < 500) {
                const dist = Math.sqrt(Math.pow(player.x - jewel.x + scrollOffset, 2) + Math.pow(player.y - jewel.y, 2));
                if (dist < 40) {
                    jewel.collected = true;
                    createCollectEffect();
                }
            }

            // Check collisions
            checkCollisions();
            
            // Update boss if active
            if (boss.active) {
                updateBoss();
            }
        }

        function updateBoss() {
            const section = getCurrentSection();
            if (section.name !== 'Boss Fight') return;

            boss.active = true;
            boss.attackTimer++;

            // Boss crystal rotation
            boss.crystal.rotation += 0.05;
            boss.crystal.glow = Math.sin(Date.now() * 0.01) * 0.5 + 0.5;

            // Fire attack pattern
            if (boss.attackTimer % 60 === 0) {
                // Launch fireball
                boss.fireballs.push({
                    x: boss.crystal.x,
                    y: boss.crystal.y,
                    targetX: player.x,
                    targetY: player.y,
                    speed: 3,
                    life: 180
                });
            }

            // Update fireballs
            for (let i = boss.fireballs.length - 1; i >= 0; i--) {
                const fb = boss.fireballs[i];
                const angle = Math.atan2(fb.targetY - fb.y, fb.targetX - fb.x);
                fb.x += Math.cos(angle) * fb.speed;
                fb.y += Math.sin(angle) * fb.speed;
                fb.life--;

                // Check fireball collision with player
                const dist = Math.sqrt(Math.pow(player.x - fb.x, 2) + Math.pow(player.y - fb.y, 2));
                if (dist < 30) {
                    die();
                    return;
                }

                if (fb.life <= 0) {
                    boss.fireballs.splice(i, 1);
                }
            }
        }

        function checkCollisions() {
            const playerRect = {
                x: player.x,
                y: player.y,
                width: player.width,
                height: player.height
            };

            for (let obstacle of obstacles) {
                const obstacleRect = {
                    x: obstacle.x - scrollOffset,
                    y: obstacle.y,
                    width: obstacle.width,
                    height: obstacle.height
                };

                if (collision(playerRect, obstacleRect) && obstacle.deadly) {
                    die();
                    return;
                }
            }
        }

        function collision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }

        function die() {
            gameState = 'dead';
            createDeathEffect();
            document.body.classList.add('death-effect');
            setTimeout(() => {
                document.body.classList.remove('death-effect');
            }, 400);
        }

        function restart() {
            gameState = 'playing';
            player.x = 150;
            player.y = canvas.height / 2;
            player.velocityY = 0;
            player.onGround = false;
            player.rotation = 0;
            player.trail = [];
            scrollOffset = 0;
            attempts++;
            currentProgress = 0;
            jewel.collected = false;
            boss.active = false;
            boss.fireballs = [];
            document.getElementById('attempts').textContent = attempts;
            hideMenuElements();
        }

        function startGame() {
            gameState = 'playing';
            generateLevel();
            hideMenuElements();
        }

        function goToMenu() {
            gameState = 'menu';
            scrollOffset = 0;
            currentProgress = 0;
            currentSection = 'Menu';
            showMenuElements();
        }

        function hideMenuElements() {
            document.getElementById('title').style.display = 'none';
            document.getElementById('subtitle').style.display = 'none';
            document.getElementById('levelInfo').style.display = 'none';
        }

        function showMenuElements() {
            document.getElementById('title').style.display = 'block';
            document.getElementById('subtitle').style.display = 'block';
            document.getElementById('levelInfo').style.display = 'block';
        }

        function createJumpParticles() {
            for (let i = 0; i < 6; i++) {
                particles.push({
                    x: player.x + player.width / 2,
                    y: player.y + player.height,
                    vx: (Math.random() - 0.5) * 5,
                    vy: Math.random() * 3 + 1,
                    life: 25,
                    maxLife: 25,
                    color: '#ff6b47',
                    size: 4
                });
            }
        }

        function createThrustParticles() {
            for (let i = 0; i < 4; i++) {
                particles.push({
                    x: player.x - 5,
                    y: player.y + player.height / 2,
                    vx: -Math.random() * 4 - 3,
                    vy: (Math.random() - 0.5) * 3,
                    life: 20,
                    maxLife: 20,
                    color: '#ffaa00',
                    size: 5
                });
            }
        }

        function createDeathEffect() {
            for (let i = 0; i < 25; i++) {
                particles.push({
                    x: player.x + player.width / 2,
                    y: player.y + player.height / 2,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    life: 40,
                    maxLife: 40,
                    color: '#ff3333',
                    size: 8
                });
            }
        }

        function createCollectEffect() {
            for (let i = 0; i < 15; i++) {
                particles.push({
                    x: jewel.x - scrollOffset,
                    y: jewel.y,
                    vx: (Math.random() - 0.5) * 6,
                    vy: (Math.random() - 0.5) * 6,
                    life: 30,
                    maxLife: 30,
                    color: '#ffdd00',
                    size: 6
                });
            }
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.2;
                p.life--;
                p.size *= 0.98;

                if (p.life <= 0 || p.size < 0.5) {
                    particles.splice(i, 1);
                }
            }
        }

        function drawBackground() {
            const section = getCurrentSection();
            const time = Date.now() * 0.001;

            // Section-specific backgrounds
            if (section.theme === 'forest') {
                // Forest background
                ctx.fillStyle = `linear-gradient(180deg, #1a2a1a 0%, #0f1f0f 50%, #051005 100%)`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw trees in background
                for (let bg of backgroundElements) {
                    if (bg.type === 'tree') {
                        const x = bg.x - scrollOffset * bg.layer;
                        if (x > -100 && x < canvas.width + 100) {
                            ctx.save();
                            ctx.scale(bg.scale, bg.scale);
                            ctx.fillStyle = '#0a0a0a';
                            ctx.fillRect(x / bg.scale, bg.y / bg.scale, 30, 100);
                            ctx.beginPath();
                            ctx.arc(x / bg.scale + 15, bg.y / bg.scale, 40, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.restore();
                        }
                    }
                }

                // Giant skeleton in background
                if (giantSkeleton.visible) {
                    const skX = giantSkeleton.x - scrollOffset * 0.2;
                    if (skX > -200 && skX < canvas.width + 200) {
                        drawGiantSkeleton(skX, giantSkeleton.y);
                    }
                }
            } else if (section.theme === 'cave') {
                // Cave background
                ctx.fillStyle = '#0a0505';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Cave walls
                ctx.fillStyle = '#1a0f0f';
                ctx.fillRect(0, 0, canvas.width, 60);
                ctx.fillRect(0, canvas.height - 60, canvas.width, 60);
                
                // Stalactites and stalagmites
                for (let i = 0; i < canvas.width; i += 40) {
                    ctx.fillStyle = '#2a1515';
                    const height = 20 + Math.sin((i + scrollOffset) * 0.02) * 15;
                    ctx.fillRect(i, 0, 20, height);
                    ctx.fillRect(i, canvas.height - height, 20, height);
                }
            } else if (section.theme === 'castle') {
                // Castle interior
                ctx.fillStyle = '#1a1010';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Castle wall pattern
                ctx.fillStyle = '#2a1a1a';
                for (let i = 0; i < canvas.width; i += 60) {
                    ctx.fillRect(i, 0, 40, canvas.height);
                }
            } else if (section.theme === 'tower') {
                // Tower interior for boss fight
                ctx.fillStyle = '#0f0505';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Tower walls
                ctx.fillStyle = '#1f0a0a';
                ctx.fillRect(0, 0, 50, canvas.height);
                ctx.fillRect(canvas.width - 50, 0, 50, canvas.height);
                
                // Mystical atmosphere
                ctx.fillStyle = `rgba(255, 100, 50, ${0.1 + Math.sin(time * 2) * 0.05})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            // Draw ground
            ctx.fillStyle = section.theme === 'cave' ? '#2a1010' : '#1a0a0a';
            ctx.fillRect(0, canvas.height - 50, canvas.width, 50);
        }

        function drawGiantSkeleton(x, y) {
            const time = Date.now() * 0.001;
            
            // Giant skeleton head
            ctx.fillStyle = '#dddddd';
            ctx.fillRect(x, y, 120, 100);
            
            // Eyes with glow
            const eyeGlow = Math.sin(time * 3) * 0.3 + 0.7;
            ctx.fillStyle = `rgba(255, 0, 0, ${eyeGlow})`;
            ctx.fillRect(x + 20, y + 20, 15, 15);
            ctx.fillRect(x + 85, y + 20, 15, 15);
            
            // Eye glow effect
            ctx.shadowColor = '#ff0000';
            ctx.shadowBlur = 20;
            ctx.fillRect(x + 20, y + 20, 15, 15);
            ctx.fillRect(x + 85, y + 20, 15, 15);
            ctx.shadowBlur = 0;
            
            // Mouth
            ctx.fillStyle = '#000';
            ctx.fillRect(x + 30, y + 70, 60, 8);
            ctx.fillRect(x + 40, y + 60, 8, 20);
            ctx.fillRect(x + 55, y + 65, 8, 15);
            ctx.fillRect(x + 70, y + 60, 8, 20);
            
            // Jaw bones
            ctx.fillStyle = '#aaaaaa';
            ctx.fillRect(x + 10, y + 90, 100, 20);
        }

        function drawPlayer() {
            const section = getCurrentSection();
            
            // Draw player trail
            for (let i = 0; i < player.trail.length; i++) {
                const alpha = (player.trail.length - i) / player.trail.length * 0.3;
                ctx.globalAlpha = alpha;
                ctx.fillStyle = player.color;
                ctx.fillRect(player.trail[i].x - 2, player.trail[i].y - 2, 4, 4);
            }
            ctx.globalAlpha = 1;

            ctx.save();
            ctx.translate(player.x + player.width / 2, player.y + player.height / 2);
            ctx.rotate(player.rotation);

            if (section.mode === 'cube') {
                // Skeletal cube
                ctx.fillStyle = player.color;
                ctx.fillRect(-player.width / 2, -player.height / 2, player.width, player.height);
                
                // Skull face
                ctx.fillStyle = '#000';
                ctx.fillRect(-8, -12, 4, 4); // left eye
                ctx.fillRect(4, -12, 4, 4);  // right eye
                ctx.fillRect(-6, -4, 12, 2); // mouth
                ctx.fillRect(-2, -2, 4, 4);  // nose
                
                // Bone pattern
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(-10, 0);
                ctx.lineTo(10, 0);
                ctx.moveTo(0, -10);
                ctx.lineTo(0, 10);
                ctx.stroke();
            } else if (section.mode === 'ship') {
                // Skeletal ship
                ctx.fillStyle = player.color;
                ctx.beginPath();
                ctx.moveTo(15, 0);
                ctx.lineTo(-15, -8);
                ctx.lineTo(-10, 0);
                ctx.lineTo(-15, 8);
                ctx.closePath();
                ctx.fill();
                
                // Ship details
                ctx.fillStyle = '#fff';
                ctx.fillRect(-8, -3, 8, 6);
                ctx.fillStyle = '#000';
                ctx.fillRect(-6, -2, 2, 2);
                ctx.fillRect(-3, -2, 2, 2);
            } else if (section.mode === 'spider') {
                // Skeletal spider
                ctx.fillStyle = player.color;
                ctx.fillRect(-player.width / 2, -player.height / 2, player.width, player.height);
                
                // Spider legs
                for (let i = 0; i < 4; i++) {
                    const angle = (i * Math.PI / 2) + player.rotation;
                    const legX = Math.cos(angle) * 15;
                    const legY = Math.sin(angle) * 15;
                    ctx.strokeStyle = player.color;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(legX, legY);
                    ctx.stroke();
                }
                
                // Spider body details
                ctx.fillStyle = '#000';
                ctx.fillRect(-4, -6, 2, 2);
                ctx.fillRect(2, -6, 2, 2);
            }

            ctx.restore();
        }

        function drawObstacles() {
            const section = getCurrentSection();
            
            for (let obstacle of obstacles) {
                const x = obstacle.x - scrollOffset;
                
                if (x < -obstacle.width || x > canvas.width + 50) continue;

                ctx.fillStyle = obstacle.deadly ? '#cc3333' : '#666';

                if (obstacle.type === 'tree_spike') {
                    // Forest spike (tree branch)
                    ctx.fillStyle = '#2a1a0a';
                    ctx.fillRect(x, obstacle.y, obstacle.width, obstacle.height);
                    
                    // Branch details
                    ctx.fillStyle = '#4a3a1a';
                    for (let i = 0; i < 3; i++) {
                        ctx.fillRect(x + i * 12, obstacle.y + i * 15, 8, 4);
                    }
                } else if (obstacle.type === 'cave_spike_up') {
                    // Cave stalagmite
                    ctx.fillStyle = '#3a2020';
                    ctx.beginPath();
                    ctx.moveTo(x, obstacle.y + obstacle.height);
                    ctx.lineTo(x + obstacle.width / 2, obstacle.y);
                    ctx.lineTo(x + obstacle.width, obstacle.y + obstacle.height);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Dripping effect
                    ctx.fillStyle = '#2a1515';
                    ctx.fillRect(x + obstacle.width / 2 - 2, obstacle.y, 4, 8);
                } else if (obstacle.type === 'cave_spike_down') {
                    // Cave stalactite
                    ctx.fillStyle = '#3a2020';
                    ctx.beginPath();
                    ctx.moveTo(x, obstacle.y);
                    ctx.lineTo(x + obstacle.width / 2, obstacle.y + obstacle.height);
                    ctx.lineTo(x + obstacle.width, obstacle.y);
                    ctx.closePath();
                    ctx.fill();
                } else if (obstacle.type === 'castle_spike') {
                    // Castle spike
                    ctx.fillStyle = '#4a3a3a';
                    ctx.beginPath();
                    ctx.moveTo(x, obstacle.y + obstacle.height);
                    ctx.lineTo(x + obstacle.width / 2, obstacle.y);
                    ctx.lineTo(x + obstacle.width, obstacle.y + obstacle.height);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Castle detailing
                    ctx.fillStyle = '#6a5a5a';
                    ctx.fillRect(x + 5, obstacle.y + obstacle.height - 10, obstacle.width - 10, 10);
                } else if (obstacle.type === 'branch_platform' || obstacle.type === 'castle_platform') {
                    // Platform
                    ctx.fillStyle = obstacle.type === 'branch_platform' ? '#3a2a1a' : '#5a4a4a';
                    ctx.fillRect(x, obstacle.y, obstacle.width, obstacle.height);
                    
                    // Platform details
                    ctx.fillStyle = obstacle.type === 'branch_platform' ? '#4a3a2a' : '#6a5a5a';
                    ctx.fillRect(x, obstacle.y, obstacle.width, 3);
                } else {
                    // Default obstacle
                    ctx.fillRect(x, obstacle.y, obstacle.width, obstacle.height);
                }

                // Add glow effect for deadly obstacles
                if (obstacle.deadly) {
                    ctx.shadowColor = '#ff3333';
                    ctx.shadowBlur = 8;
                    ctx.globalAlpha = 0.3;
                    ctx.fillRect(x, obstacle.y, obstacle.width, obstacle.height);
                    ctx.shadowBlur = 0;
                    ctx.globalAlpha = 1;
                }
            }
        }

        function drawJewel() {
            if (jewel.collected || scrollOffset > 1000) return;
            
            const time = Date.now() * 0.001;
            const x = jewel.x - scrollOffset;
            const y = jewel.y + Math.sin(time * 2) * 5; // Floating animation
            
            jewel.glow = Math.sin(time * 4) * 0.3 + 0.7;
            
            // Jewel glow
            ctx.shadowColor = '#ffdd00';
            ctx.shadowBlur = 20;
            ctx.globalAlpha = jewel.glow;
            
            // Diamond shape
            ctx.fillStyle = '#ffdd00';
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(time);
            ctx.beginPath();
            ctx.moveTo(0, -15);
            ctx.lineTo(10, 0);
            ctx.lineTo(0, 15);
            ctx.lineTo(-10, 0);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
            
            ctx.shadowBlur = 0;
            ctx.globalAlpha = 1;
        }

        function drawBoss() {
            if (!boss.active) return;
            
            const time = Date.now() * 0.001;
            const bossX = boss.x - scrollOffset;
            
            if (bossX < -200 || bossX > canvas.width + 200) return;
            
            // Giant skeleton boss head
            ctx.fillStyle = '#dddddd';
            ctx.fillRect(bossX, boss.y, 150, 120);
            
            // Boss eyes with intense glow
            const eyeGlow = Math.sin(time * 5) * 0.4 + 0.6;
            ctx.shadowColor = '#ff0000';
            ctx.shadowBlur = 30;
            ctx.fillStyle = `rgba(255, 0, 0, ${eyeGlow})`;
            ctx.fillRect(bossX + 25, boss.y + 25, 20, 20);
            ctx.fillRect(bossX + 105, boss.y + 25, 20, 20);
            ctx.shadowBlur = 0;
            
            // Boss mouth
            ctx.fillStyle = '#000';
            ctx.fillRect(bossX + 40, boss.y + 80, 70, 12);
            
            // Boss teeth
            ctx.fillStyle = '#ffffff';
            for (let i = 0; i < 6; i++) {
                ctx.fillRect(bossX + 45 + i * 10, boss.y + 75, 6, 15);
            }
            
            // Orange crystal
            const crystalX = boss.crystal.x - scrollOffset;
            const crystalY = boss.crystal.y + Math.sin(time * 3) * 3;
            
            ctx.save();
            ctx.translate(crystalX, crystalY);
            ctx.rotate(boss.crystal.rotation);
            
            // Crystal glow
            const crystalGlow = boss.crystal.glow;
            ctx.shadowColor = '#ff6600';
            ctx.shadowBlur = 25;
            ctx.globalAlpha = crystalGlow;
            
            // Diamond crystal
            ctx.fillStyle = '#ff6600';
            ctx.beginPath();
            ctx.moveTo(0, -20);
            ctx.lineTo(15, 0);
            ctx.lineTo(0, 20);
            ctx.lineTo(-15, 0);
            ctx.closePath();
            ctx.fill();
            
            ctx.restore();
            ctx.shadowBlur = 0;
            ctx.globalAlpha = 1;
            
            // Draw fireballs
            for (let fireball of boss.fireballs) {
                const fbX = fireball.x - scrollOffset;
                ctx.shadowColor = '#ff4400';
                ctx.shadowBlur = 15;
                ctx.fillStyle = '#ff4400';
                ctx.beginPath();
                ctx.arc(fbX, fireball.y, 12, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
            
            // Boss health bar
            if (boss.health < boss.maxHealth) {
                const barWidth = 200;
                const barHeight = 10;
                const barX = canvas.width / 2 - barWidth / 2;
                const barY = 30;
                
                ctx.fillStyle = '#333';
                ctx.fillRect(barX, barY, barWidth, barHeight);
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(barX, barY, (boss.health / boss.maxHealth) * barWidth, barHeight);
                ctx.strokeStyle = '#fff';
                ctx.strokeRect(barX, barY, barWidth, barHeight);
            }
        }

        function drawDecorations() {
            for (let decoration of decorations) {
                const x = decoration.x - scrollOffset;
                
                if (x < -100 || x > canvas.width + 100) continue;

                ctx.save();
                
                if (decoration.type === 'castle_column') {
                    ctx.fillStyle = '#4a3a3a';
                    ctx.fillRect(x, decoration.y, 40, decoration.height);
                    
                    // Column details
                    ctx.fillStyle = '#6a5a5a';
                    ctx.fillRect(x, decoration.y, 40, 20); // Capital
                    ctx.fillRect(x + 5, decoration.y + 20, 30, decoration.height - 40);
                    ctx.fillRect(x, decoration.y + decoration.height - 20, 40, 20); // Base
                }
                
                ctx.restore();
            }
        }

        function drawParticles() {
            particleCtx.clearRect(0, 0, particleCanvas.width, particleCanvas.height);
            
            for (let particle of particles) {
                const alpha = particle.life / particle.maxLife;
                particleCtx.globalAlpha = alpha;
                particleCtx.fillStyle = particle.color;
                particleCtx.beginPath();
                particleCtx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                particleCtx.fill();
            }
            
            particleCtx.globalAlpha = 1;
        }

        function updateProgress() {
            currentProgress = Math.min(100, (scrollOffset / levelLength) * 100);
            document.getElementById('progress').textContent = Math.floor(currentProgress) + '%';
            document.getElementById('section').textContent = currentSection;
            
            if (currentProgress > bestProgress) {
                bestProgress = currentProgress;
                document.getElementById('best').textContent = Math.floor(bestProgress) + '%';
            }
        }

        function gameLoop() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (gameState === 'playing') {
                // Update game state
                scrollOffset += gameSpeed;
                updatePlayer();
                updateParticles();
                updateProgress();

                // Check if level is complete
                if (scrollOffset >= levelLength) {
                    goToMenu();
                }
            }

            // Draw everything
            drawBackground();
            drawDecorations();
            drawObstacles();
            drawJewel();
            drawBoss();
            
            if (gameState === 'playing' || gameState === 'dead') {
                drawPlayer();
            }
            
            drawParticles();

            requestAnimationFrame(gameLoop);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            particleCanvas.width = window.innerWidth;
            particleCanvas.height = window.innerHeight;
        });

        // Start the game loop
        gameLoop();
